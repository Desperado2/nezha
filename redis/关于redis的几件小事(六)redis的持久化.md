### 1.redis持久化的意义
redis持久化的意义，在于 **故障恢复** 。   
如果没有对数据进行持久化，那么如果redis遇到灾难性的故障，就会丢失所有的数据。  
如果通过redis的持久化机制将数据持久化到硬盘上面去，然后在定期将磁盘上的文件备份到一起其他的服务器上面(比如:云服务器),这样就可以保证即使redis遇到了灾难事故，也可以使用提前备份的文件对数据进行回复，之后丢失最近的一部分数据，而不会全部丢失数据。

### 2.redis的两种持久化方式  
redis的持久化是跟高可用相关的。redis有两种持久化的方式，分别是RDB和AOF。  
#### (1)RDB和AOF两种持久化机制介绍   
RDB持久化机制，对redis中的数据执行周期性的持久化。   
AOF机制对每条写入命令作为日志，以append-only的模式写入一个日志文件中，在redis重启的时候，可以通过回复AOF日志中的写入指令来重新构建整个数据集。   
如果我们想要redis仅仅作为纯内存的缓存来用，那么可以禁止RDB和AOF所有持久化机制。   
通过RDB或AOF，都可以将redis内存中的数据给持久化到磁盘上面去，然后可以将这些数据备份到别的地方去。   
如果redis挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动redis，redis就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务。  
如果同时使用RDB和AOF两种持久化机制，那么在redis重启的时候，会使用AOF来重新构建数据，因为AOF中的数据更加完整。  
#### (2)RDB持久化机制的优点  
 ①RDB会生成多个数据文件，每个数据文件代表了某一个时刻中redis的数据，这种多个数据文件的方式，非常适合做冷备。   
**做冷备优势** ：由redis去控制固定时长生成快照文件的事情，比较方便；在最坏的情况下，提供数据恢复的时候，比AOF速度快。   

②RDB持久化对redis对外提供的读写服务，影响非常小，可以让redis保持高性能，因为redis主进程会fork一个子进程，让子进程执行磁盘的IO操作来进行RDB持久化。  
**原因** ：RDB直接写redis内存，只是在一定时候，才会将数据写入内存。AOF每次都是直接写文件，虽然可以快速的写os cache中，但还是要耗费一定时间，比RDB略慢一些。  

③相对于AOF持久化机制来说，直接基于RDB数据文件来重启和恢复redis进程，更加快速。  
**原因** ：AOF，存放的指令日志，做数据恢复的时候，其实是要回放和执行所有的指令日志，来恢复出来内存中的所有数据的。
RDB，就是一份数据文件，恢复的时候，直接加载到内存中即可。   

#### (3)RDB持久化的缺点  
①如果想要在redis故障时，尽可能少的丢失数据，那么RDB没有AOF好。因为RDB都是每隔一段时间去做的备份，如果redis宕机，那么就会丢失这一段时间内所有的数据。所以不适合做第一优先的恢复方案。   

②RDB每次在fork子进程来执行RDB快照文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，设置数秒。  
一般不要让RDB的间隔时间太长，否则每次生成的RDB文件太大了，对redis本身的性能也有影响。  

#### (4)AOF持久化的优点  
①AOF可以更好的保护数据不丢失。   
**原因** ：一般AOF会每隔1秒，通过一个后台进程执行一次fsync操作。将 os cache里面的数据刷到磁盘里面去，这样就算redis挂了，也至多丢失一秒钟的数据。  

②AOF日志文件是以append-only模式写入，所以没有任何的磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件维普破损，也很容易修复。  

③AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。  
**原因** ：因为在rewrite log的时候，会对其中的指令进行压缩，创建出一份恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的merge后的日志文件ready的时候，再交换新老日志文件即可。  

④AOF日志文件的命令是通过非常可读的方式进行记录的，这非常适合做 误删除这种操作的紧急回复。
**原因** ：比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据。

#### (5)AOF持久化的缺点  
①对于同一份数据来说，AOF日志通常比RDB文件更大。   

②AOF开启后，支持的QPS会比RDB支持的QPS低。   
**原因** ：因为AOF一般会配置成每秒fsync一次日志文件，当然，每一秒fsync性能还是可以的。   

③AOF比RDB更加脆弱，可能会出现恢复出来的数据不一致的情况。类似AOF这种较为复杂的基于命令日志/merge/回放的方式，比基于RDB每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有bug。不过AOF就是为了避免rewrite过程导致的bug，因此每次rewrite并不是基于旧的指令日志进行merge的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。

④在做数据恢复的时候比较慢，想用来做冷备、定期备份比较麻烦，可能要自己写脚本去做。不太适合做冷备。  

#### (6)RDB和AOF如何选择   
①不要仅仅使用RDB，这样会导致丢失很多数据。   

②也不要仅仅使用AOF，因为使用AOF做冷备恢复速度太慢，还有可能会出现数据不一致。  

③综合使用RDB和AOF两种持久化机制，用AOF保证数据不丢失，作为数据恢复的第一选择；用RDB来做不同程度的冷备，在AOF文件都丢失或者不可以的时候，还可以用RDB来进行快速的数据恢复。
















