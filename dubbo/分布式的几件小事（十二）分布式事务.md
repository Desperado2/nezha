### 1.两阶段提交方案/XA方案。       
**原理** 这个就是所谓的XA事务，两阶段提交，有一个事务管理器的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复ok，那么就正式提交事务，在各个数据库上执行操作；如果任何一个数据库回答不ok，那么就回滚事务。    

**适用场景**：    
比较适合单块应用里，跨多个库的分布式事务。    
**缺点**      
因为严重依赖于数据库层面来搞复杂的事务，效率很低，不适合高并发的场景。          

### 2.TCC方案     
TCC全称是：Try、Confirm、Cancel。   
**原理**       
使用到了补偿的概念。整个过程分为三个阶段：         
①Try阶段：这个阶段说的是对各个服务的资源做检查以及对资源进行锁定或者预留。    
②Confirm阶段: 执行实际的操作。     
③Cancel阶段：如果操作中任何一个失败了，那么就需要回滚进行补偿。    

**适用场景**    
这种方案说实话几乎很少用人使用，但是也有使用的场景。这个就是除非你是真的一致性要求太高，是你系统中核心之核心的场景，比如常见的就是资金类的场景，那你可以用TCC方案了，自己编写大量的业务逻辑，自己判断一个事务中的各个环节是否ok，不ok就执行补偿/回滚代码。
而且最好是你的各个业务执行的时间都比较短。    
**缺点** ：     
事物回滚严重依赖于自己写代码来回滚和补偿，会造成补偿代码巨大，还需要自己确定回滚逻辑，代码很难维护。    

### 3.本地消息表方案     
这是eBay搞出来的一种思想。流程是这样的。     
**原理**      
①A系统在自己本地一个事务里操作的同时，插入一条数据到消息表。     
②接着A系统将这个消息发送到MQ中去。     
③B系统接收到消息之后，在一个事务里，往自己消息表里插入一条数据，同时保证其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务就会回滚，这样保证不会重复处理消息。      
④B系统执行成功之后，就会更新自己本地消息表的状态以及A系统消息表的状态。    
⑤如果B系统处理失败了，那么就不会更新消息表状态，那么此时A系统就会定时扫描自己的消息表，如果有没处理的消息，会再次发送到MQ中去，让B去处理。     
⑥这个方案保证了最终一致性，哪怕B事务失败了。但是A会不断重发消息，直到B那边成功为止。     
**缺点**     
严重依赖于数据库的消息表来管理事务。     
高并发不好扩展，一般很少用。     

### 4可靠消息最终一致性方案   
这个方案就是不使用本地消息表，直接基于MQ实现事务，比如RocketMQ就支持消息事务。     
**原理**      
①A系统先发送一个prepared消息到mq，如果这个prepared消息发送失败那么就直接取消操作。    
②如果这个消息发送成功了，那么接着执行本地事务，如果成功就告诉mq发送确认消息，如果失败就告诉mq回滚消息。    
③如果发送了确认消息，那么此时B系统就会收到确认消息，然后执行本地事务。    
④mq会自动定时轮询prepared消息回调你的接口，一般来说接口里就可以查询数据库看之前本地事务是否执行，如果回滚了，那这里也进行回滚。这个就是避免可能本地事务执行成功了，确认消息发送失败了。    
⑤要是B的事务执行失败了，字段不断重试知道成功，如果实在不行，就针对重要的业务进行回滚，比如B系统本地回滚后，想办法通知系统A也回滚；或者发送报警由人工来进行手动回滚。     
**适用场景**     
这个适用场景比较多。     

### 5.最大努力通知方案    
**原理**     
①系统A本地事务执行完毕之后，发送消息到MQ。    
②这里会有个专门消费MQ的最大努力通知服务，这个服务会消费MQ然后写入数据库中记录下来，或者放入一个内存队列，接着调用系统B的接口。     
③要是B执行成功了就ok了。要是B执行失败了，那么最大努力通知服务就会定时尝试重新调用系统B，反复N次，最后还是不行就放弃。    

### 6.事务原则   

99%的分布式接口调用，不要做分布式事务，直接就是监控（发邮件、发短信）、记录日志（一旦出错，完整的日志）、事后快速的定位、排查和出解决方案、修复数据。